<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Tuesday, March 25, 2025, 7:36 PM -->
<!-- MuClient version 5.07-pre -->

<!-- Plugin "Inquisitor" generated by Plugin Wizard -->

<muclient>
<plugin
   name="InquisitorDatabase"
   author="Bartoc"
   id="a0df32eada26b5a8bdec0c87"
   language="Lua"
   purpose="Builds an encyclopedia of mobs using Interrogate data"
   save_state="y"
   date_written="2025-03-25 19:35:24"
   requires="5.07"
   version="1.0"
   >

</plugin>


<!--  Variables  -->

<variables>
</variables>

<!--  Script  -->


<script>
<![CDATA[



require 'gmcphelper'
http = require("socket.http")
https = require("ssl.https")
--json = require ("dkjson")
ltn12 = require("ltn12")

db = "InquisitorDB"
mob = {}
interrogate_ready = true
debug = false
inquisitor = ""

function ToggleDebug()
  if debug then
    Note("Debug mode disabled")
  else
    Note("Debug mode enabled")
  end
  debug = not debug
end

function PoopFunc()
  Note("poop")
end

function TestHTTP()
  Note("Checking connection to the online database...")
  bodytable = {
  sql = "SELECT * FROM mobs",
  database = "inquisitor.sqlite"
  }
  bodystring = [[{
  "sql": "SELECT * FROM mobs",
  "database": "inquisitor.sqlite"
  }]]
  --body = json.encode (bodytable, { indent = true })
  respbody = {}
  result, respcode, respheaders, respstatus = https.request {
      method = "POST",
      url = "https://cgop8sf0hz.g3.sqlite.cloud/v2/weblite/sql",
      source = ltn12.source.string(bodystring),
      headers = {
          ["authorization"] = "Bearer sqlitecloud://cgop8sf0hz.g3.sqlite.cloud:8860?apikey=4MxImOlEzZJTXEPeA396qzEtrmuuQcvU2v10Hkp0RyI",
          ["content-type"] = "application/json",
          ["content-length"] = tostring(#bodystring)
      },
      sink = ltn12.sink.table(respbody)
  }
  
  --respbody = table.concat(respbody)


  --Note("HTTP result: " .. dump(respbody[1]))
end

function IfCatalogued(uniqid)
  if debug then Note("Checking if " .. uniqid .. " catalogued") end
  Note("SQL code: " .. inquisitor:exec("SELECT EXISTS(SELECT 1 FROM mobs WHERE uniqid=\"" .. uniqid .. "\")")) -- returns 0 (sqlite3.OK)
end

function CheckIfCataloguedAndReturn(uniqid)
  if debug then Note("Attempting to retrieve entry for: " .. uniqid) end
  
  results = {}
  captured = false
  for row in inquisitor:nrows("SELECT * FROM mobs WHERE uniqid=\"" .. uniqid .. "\"") do table.insert(results, row) end
  if results[1] then captured = true end

  if debug then Note(captured) end
  if debug then Note(dump(results[1])) end
  
  return captured, results
end


function ResetMob()
    mob = {
      uniqid = "defaultID", 
      partial = "false",
      name = "poop", 
      room = "poop", 
      zone = "poop", 
      level = 0, 
      guild = "poop", 
      subclass = "poop",
      identical = 0, 
      hp = 0, 
      alignment = "poop", 
      sortedresists = "nothingyet",
      bash = 0.0, 
      pierce = 0.0, 
      slash = 0.0, 
      acid = 0.0, 
      air = 0.0, 
      cold = 0.0, 
      disease = 0.0, 
      earth = 0.0, 
      energy = 0.0, 
      fire = 0.0, 
      holy = 0.0, 
      light = 0.0, 
      electric = 0.0, 
      magic = 0.0, 
      mental = 0.0, 
      negative = 0.0, 
      poison = 0.0, 
      shadow = 0.0, 
      sonic = 0.0, 
      water = 0.0,
      contributor = "Anonymous"
    }
end

function OnPluginInstall()
  Note("InquisitorDB installed.")
  GenTable() -- might throw an error rn
  ResetMob()
  TestHTTP()
end

function WipeDB()
  inquisitor:exec([[
    DROP TABLE IF EXISTS mobs;
      ]])
  Note("Wiped Inquisitor DB")
end

function CloseDB()
  inquisitor:close()
  Note("Closed DB")
end

function GenTable()

  inquisitor=sqlite3.open("inquisitor.sqlite")
  if debug then Note("Opened DB") end
  inquisitor:exec([[
    CREATE TABLE IF NOT EXISTS mobs (
        uniqid TEXT NOT NULL PRIMARY KEY,
        partial TEXT NOT NULL,
        name      TEXT NOT NULL,
        room      TEXT NOT NULL,
        zone      TEXT NOT NULL,
        level     INT NOT NULL,
        guild      TEXT NOT NULL,
        subclass      TEXT NOT NULL,
        identical   INT,
        hp    INT,
        alignment   TEXT NOT NULL,
        sortedresists   TEXT,
        bash    REAL,
        pierce    REAL,
        slash    REAL,
        acid    REAL,
        air    REAL,
        cold    REAL,
        disease    REAL,
        earth    REAL,
        energy    REAL,
        fire    REAL,
        holy    REAL,
        light    REAL,
        electric     REAL,
        magic    REAL,
        mental    REAL,
        negative    REAL,
        poison    REAL,
        shadow    REAL,
        sonic    REAL,
        water    REAL,
        contributor TEXT
      );
      ]])
end


function ResetInterrogate()
  interrogate_ready = true
  Note("Interrogate ready")
  ResetMob()
end

function InterrogateInjection(target)
  --DatabasePrepare(db, "SELECT * FROM mobs WHERE") -- check for key
  --DatabaseStep (db)
  --DatabaseFinalize (db)

  if interrogate_ready then
    Send("spellup silent")
    Send("interrogate " .. target)
    Send("kill " .. target)
  else
    Send("spellup silent")
    Send("kill " .. target)
  end
end

function InterrogationSuccessful()
  Note("Interrogation successful.")
  interrogate_ready = false
  mob.zone = "currentzone"
  EnableTriggerGroup("capture_entry", true)
  if debug then Note("Trigger group activated") end
end

function Capture(flag, data)
  if debug then Note("Data captured - " .. flag .. ": " .. data) end
  if type(data) == "string" then data = data:gsub("'", "''") end -- single quotes break sqlite
  mob[flag] = data
end

function CaptureResist(name, data)
  sorted = {}
  --we're just capturing these separately to build an easily sorted list
  --ordering resists on capture reduces complexity of weakpoint analysis on run I think
  Capture(string.lower(name), data)
  -- Capture("ResistanceList", sorted)
end

function ParseAlignment(flavortext)
  alignvalue = ""
  flavortext_short = string.sub(flavortext, string.len(mob.name)+4, string.len(flavortext)-1) -- removes mob name + "is" + ending period
  -- map flavor text to alignment range
  Capture("alignment", flavortext_short)
end


immunities = {}
function ProcessImmunities(raw)
  for immunity in raw:gmatch("%w+") do 
    table.insert(immunities, immunity) 
  end
end

function SortResists()
  -- sort resists and convert to string with > delimiter
end

function PostEntry()

  -- First, stop capturing and stamp it with the zone, room, and name of the contributor
  EnableTriggerGroup("capture_entry", false)

  mob.zone = gmcp("room.info.zone")
  mob.room = gmcp("room.info.name")
  mob.room = mob.room:gsub("'", "''") -- single quotes break sqlite i.e. "Bartoc's Throne"
  mob.uniqid = mob.zone .. "+" .. mob.room .. "+" .. mob.name
  mob.contributor = gmcp("char.base.name")

  -- Second, JUST in case the mob somehow had a resistance AND an immunity to the same type, we overwrite with the immunity's 100%
  for key, value in pairs(immunities) do 
    if debug then Note("Immunity: " .. value) end
    mob[value] = 100.0
  end
  immunities = {}

  
  -- Third, convert the table to a SQL entry and insert
  -- Let's just make sure that mob doesn't already exist in the table for some reason, though. Update this when Oracle is added 
  -- keep this for later: SELECT EXISTS(SELECT 1 FROM mobs WHERE iniqud="tag")
  
  if debug then Note(dump(mob)) end
  captured, existingentry = CheckIfCataloguedAndReturn(mob.uniqid)
  if not captured then
    inquisitor:exec(string.format([[
      INSERT INTO mobs (
      uniqid, partial, name, room, zone, level, guild, subclass, identical, hp, alignment, sortedresists, bash, pierce, slash, acid, air, cold, disease, earth, energy, fire, holy, light, electric, magic, mental, negative, poison, shadow, sonic, water, contributor)
      VALUES 
      ('%s', '%s', '%s', '%s', '%s', %d, '%s', '%s', %d, %d, '%s', '%s', %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, '%s')
      ]], 
      mob.uniqid, mob.partial, mob.name, mob.room, mob.zone, mob.level, mob.guild, mob.subclass, mob.identical, mob.hp, mob.alignment, mob.sortedresists, mob.bash, mob.pierce, mob.slash, mob.acid, mob.air, mob.cold, mob.disease, mob.earth, mob.energy, mob.fire, mob.holy, mob.light, mob.electric, mob.magic, mob.mental, mob.negative, mob.poison, mob.shadow, mob.sonic, mob.water, mob.contributor))
    
    if inquisitor:errmsg() == "not an error" then
        Note("Mob info for \"" .. mob.name .. "\" successfully captured to database.")
    else
        Note("Database error: " .. inquisitor:errmsg())
        Note("Mob data dump: " .. dump(mob))
        Note("This shouldn't happen: please contact Bartoc in-game or on the Aardwolf Discord server and send the above error message and data dump.")
    
    end
  else
    Note("Mob already in database.")
  end
  
  -- Fourth, handle database errors. We're silencing duplicate entry errors for now


end


function HeaderDisable()
  EnableTrigger("header", false)
end

function DumpMob()
  Note(dump(mob))
end

function dump(o)
   if type(o) == 'table' then
      local s = '{ '
      for k,v in pairs(o) do
         if type(k) ~= 'number' then k = '"'..k..'"' end
         s = s .. '['..k..'] = ' .. dump(v) .. ','
      end
      return s .. '} '
   else
      return tostring(o)
   end
end



]]>
</script>



<aliases> -- interrrogate interrupt alias
  <alias
   match="k *"
   enabled="y"
   send_to="12"
   sequence="100"
  >
    <send>InterrogateInjection("%1")</send>
  </alias>
  <alias
   match="inq-debug"
   enabled="y"
   send_to="12"
   sequence="100"
  >
    <send>ToggleDebug()</send>
  </alias>
  <alias
   match="inq-wipedb"
   enabled="y"
   send_to="12"
   sequence="100"
  >
    <send>WipeDB()</send>
  </alias>
  <alias
   match="inq-thttp"
   enabled="y"
   send_to="12"
   sequence="100"
  >
    <send>TestHTTP()</send>
  </alias>
  <alias
   match="inq-tquery"
   enabled="y"
   send_to="12"
   sequence="100"
  >
    <send>ReturnCatalogued("logging+Wandering through the ironwoods+A creaking Ironwood")</send>
  </alias>
    <alias
   match="inq-closedb"
   enabled="y"
   send_to="12"
   sequence="100"
  >
    <send>CloseDB()</send>
  </alias>
    <alias
   match="inq-testinsert"
   enabled="y"
   send_to="12"
   sequence="100"
  >
    <send>TestInsert()</send>
  </alias>
    <alias
   match="inq-dumpmob"
   enabled="y"
   send_to="12"
   sequence="100"
  >
    <send>DumpMob()</send>
  </alias>
</aliases>

<!--  Triggers  -->

<triggers>
  <trigger
   enabled="y"
   name="interrogatecooldown"
   match="## You may now use Interrogation abilities."
   regexp="y"
   omit_from_output="y"
   send_to="12"
   sequence="101"
  >
  <send>ResetInterrogate()</send>
  </trigger>
  <trigger
   enabled="y"
   group="start_inquisitor"
   match="^As you mercilessly interrogate"
   regexp="y"
   omit_from_output="y"
   send_to="12"
   sequence="99"
  >
  <send>InterrogationSuccessful()</send>
  </trigger>
  <trigger
   enabled="n"
   group="capture_entry"
   name="header"
   match="----------------------------------------------------------------"
   omit_from_output="y"
   send_to="12"
   sequence="100"
  >
  <send>HeaderDisable()</send>
  </trigger>
  <trigger
   enabled="n"
   group="capture_entry"
   match="Mob Short Name   : (([,'\-\w\.]\s?)+)$"
   omit_from_output="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>Capture("name", "%1")</send>
  </trigger>
  <trigger
   enabled="n"
   group="capture_entry"
   match="Mob Base Level   : ([\d]+)$"
   regexp="y"
   omit_from_output="y"
   send_to="12"
   sequence="100"
  >
  <send>Capture("level", "%1")</send>
  </trigger>
  <trigger
   enabled="n"
   group="capture_entry"
   match="Guild            : (([,'\-\w]\s?)+)$"
   omit_from_output="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>Capture("guild", "%1")</send>
  </trigger>
  <trigger
   enabled="n"
   group="capture_entry"
   match="Subclass         : (([,'\-\w]\s?)+)$"
   omit_from_output="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>Capture("subclass", "%1")</send>
  </trigger>
    <trigger
   enabled="n"
   group="capture_entry"
   match="Identical Mobs   : ([\d]+)$"
   omit_from_output="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>Capture("identical", "%1")</send>
  </trigger>
    <trigger
   enabled="n"
   group="capture_entry"
   match="Times Killed     : ([\d]+)$"
   omit_from_output="y"
   regexp="y"
   sequence="100"
  >
  </trigger>
    <trigger
   enabled="n"
   group="capture_entry"
   match="Mob Hp           : *([\d]+)\/([\d]+)"
   omit_from_output="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>Capture("hp", "%2")</send>
  </trigger>
    <trigger
   enabled="n"
   group="capture_entry"
   match="Alignment        : (([,'\-\.\w]\s?)+)$"
   regexp="y"
   omit_from_output="y"
   send_to="12"
   sequence="100"
  >
  <send>ParseAlignment("%1")</send>
  </trigger>
  <trigger
   enabled="n"
   group="capture_entry"
   name="immunities"
   match="^Immunities       : (.*)$"
   regexp="y"
   omit_from_output="y"
   send_to="12"
   sequence="100"
  >
  <send>ProcessImmunities("%1")</send>
  </trigger>
  <trigger
   enabled="n"
   group="capture_entry"
   match="Note             : (([,'\-\.\w]\s?)+)$"
   regexp="y"
   omit_from_output="y"
   sequence="100"
  >
  </trigger> -- we're just throwing away the notes, they're too general to be useful
  <trigger
   enabled="n"
   group="capture_entry"
   match="------------------------- [ Resistances ] ----------------------"
   omit_from_output="y"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="n"
   group="capture_entry"
   match="([^\s]+)[\s:]+([0-9\-\.]+)%      ([^\s]+)[\s:]+([0-9\-\.]+)%"
   regexp="y"
   omit_from_output="y"
   send_to="12"
   sequence="99"
  >
  <send>CaptureResist("%1", "%2")
  CaptureResist("%3", "%4")</send> -- fucking disgusting but it's the easy way to capture 2 resists a line
  </trigger>
  <trigger
   enabled="n"
   group="capture_entry"
   match="([^\s]+)[\s:]+([0-9\-\.]+)%"
   regexp="y"
   omit_from_output="y"
   send_to="12"
   sequence="101"
  >
  <send>CaptureResist("%1", "%2")</send> -- if this runs alone it short circuits multiple resists on the same line due to omit output
  </trigger> 
  <trigger
   enabled="n"
   group="capture_entry"
   name="footer"
   match="----------------------------------------------------------------"
   omit_from_output="y"
   send_to="12"
   sequence="101"
  >
  <send>PostEntry()</send>
  </trigger>
</triggers>

</muclient>

