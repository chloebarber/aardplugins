<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Tuesday, March 25, 2025, 7:36 PM -->
<!-- MuClient version 5.07-pre -->

<!-- Plugin "Inquisitor" generated by Plugin Wizard -->

<muclient>
<plugin
   name="InquisitorDatabase"
   author="Bartoc"
   id="a0df32eada26b5a8bdec0c87"
   language="Lua"
   purpose="Builds a mob database using Interrogate"
   save_state="y"
   date_written="2025-03-25 19:35:24"
   requires="5.07"
   version="1.0"
   >

</plugin>


<!--  Variables  -->

<variables>
</variables>

<!--  Script  -->


<script>
<![CDATA[

db = "InquisitorDB"
mob = {}

function ResetMob()
    mob = {
      uniqid = "defaultID", 
      name = "poop", 
      room = "poop", 
      zone = "poop", 
      level = 0, 
      guild = "poop", 
      subclass = "poop",
      identical = 0, 
      hp = 0, 
      alignment = "poop", 
      bash = 0.0, 
      pierce = 0.0, 
      slash = 0.0, 
      acid = 0.0, 
      air = 0.0, 
      cold = 0.0, 
      disease = 0.0, 
      earth = 0.0, 
      energy = 0.0, 
      fire = 0.0, 
      holy = 0.0, 
      light = 0.0, 
      electric = 0.0, 
      magic = 0.0, 
      mental = 0.0, 
      negative = 0.0, 
      poison = 0.0, 
      shadow = 0.0, 
      sonic = 0.0, 
      water = 0.0
    }
end

function OnPluginInstall()
  GenTable()
end

function WipeDB()
  DatabaseExec (db, [[
    DROP TABLE IF EXISTS mobs;
      ]])
  Note("Wiped Inquisitor DB")
end

function CloseDB()
  DatabaseClose(db)
  Note("Closed DB")
end

function TestInsert()
  ResetMob()
  --Note(dump(mob))

  keys = {}
  values = {}
  for key, value in pairs(mob) do
      table.insert(keys, key)
      table.insert(values, value)
  end
  
  Note(string.format([[
  INSERT INTO mobs (
  uniqid, name, room, zone, level, guild, subclass, identical, hp, alignment, bash, pierce, slash, acid, air, cold, disease, earth, energy, fire, holy, light, electric, magic, mental, negative, poison, shadow, sonic, water)
  VALUES 
  (%s, %s, %s, %s, %d, %s, %s, %d, %d, %s, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d)
  ]], 
  mob.uniqid, mob.name, mob.room, mob.zone, mob.level, mob.guild, mob.subclass, mob.identical, mob.hp, mob.alignment, mob.bash, mob.pierce, mob.slash, mob.acid, mob.air, mob.cold, mob.disease, mob.earth, mob.energy, mob.fire, mob.holy, mob.light, mob.electric, mob.magic, mob.mental, mob.negative, mob.poison, mob.shadow, mob.sonic, mob.water))
  
  
  DatabaseExec (db, string.format([[
  INSERT INTO mobs (
  uniqid, name, room, zone, level, guild, subclass, identical, hp, alignment, bash, pierce, slash, acid, air, cold, disease, earth, energy, fire, holy, light, electric, magic, mental, negative, poison, shadow, sonic, water)
  VALUES 
  ('%s', '%s', '%s', '%s', %d, '%s', '%s', %d, %d, '%s', %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d)
  ]], 
  mob.uniqid, mob.name, mob.room, mob.zone, mob.level, mob.guild, mob.subclass, mob.identical, mob.hp, mob.alignment, mob.bash, mob.pierce, mob.slash, mob.acid, mob.air, mob.cold, mob.disease, mob.earth, mob.energy, mob.fire, mob.holy, mob.light, mob.electric, mob.magic, mob.mental, mob.negative, mob.poison, mob.shadow, mob.sonic, mob.water))
  Note("tested insert")
end

function GenTable()
  DatabaseOpen(db, GetInfo(66) .. "inquisitor.sqlite", 6)
  Note("Opened DB")
  DatabaseExec (db, [[
    CREATE TABLE IF NOT EXISTS mobs (
        uniqid TEXT NOT NULL PRIMARY KEY,
        name      TEXT NOT NULL,
        room      TEXT NOT NULL,
        zone      TEXT NOT NULL,
        level     INT NOT NULL,
        guild      TEXT NOT NULL,
        subclass      TEXT NOT NULL,
        identical   INT,
        hp    INT,
        alignment   TEXT NOT NULL,
        bash    REAL,
        pierce    REAL,
        slash    REAL,
        acid    REAL,
        air    REAL,
        cold    REAL,
        disease    REAL,
        earth    REAL,
        energy    REAL,
        fire    REAL,
        holy    REAL,
        light    REAL,
        electric     REAL,
        magic    REAL,
        mental    REAL,
        negative    REAL,
        poison    REAL,
        shadow    REAL,
        sonic    REAL,
        water    REAL
      );
      ]])
  -- DatabaseClose(db)
  -- Note("Closed DB")
end

function InterrogationSuccessful()
  Note("Interrogation successful.")
  ResetMob()
  mob.Zone = "currentzone"
  EnableTriggerGroup("capture_entry", true)
  Note("Trigger group activated")
end

function Capture(flag, data)
  Note("Data captured - " .. flag .. ": " .. data)
  mob[flag] = data
end

function CaptureRoom(name, line, wildcards, styles)
  mob["Room"] = styles[2].text
end

function CaptureResist(name, data)
  sorted = {}
  --we're just capturing these separately to build an easily sorted list
  --ordering resists on capture reduces complexity of weakpoint analysis on run I think
  Capture(string.lower(name), data)
  -- Capture("ResistanceList", sorted)
end

function ParseAlignment(flavortext)
  alignvalue = ""
  alignvalue = flavortext
  -- map flavor text to alignment range
  Capture("Alignment", alignvalue)
end

function PostEntry()
  mob.uniqid = mob.zone .. mob.room .. mob.name
  --Note(dump(mob))
  
  DatabaseExec (db, string.format([[
    INSERT INTO mobs (
    uniqid, name, room, zone, level, guild, subclass, identical, hp, alignment, bash, pierce, slash, acid, air, cold, disease, earth, energy, fire, holy, light, electric, magic, mental, negative, poison, shadow, sonic, water)
    VALUES 
    ('%s', '%s', '%s', '%s', %d, '%s', '%s', %d, %d, '%s', %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d)
    ]], 
    mob.uniqid, mob.name, mob.room, mob.zone, mob.level, mob.guild, mob.subclass, mob.identical, mob.hp, mob.alignment, mob.bash, mob.pierce, mob.slash, mob.acid, mob.air, mob.cold, mob.disease, mob.earth, mob.energy, mob.fire, mob.holy, mob.light, mob.electric, mob.magic, mob.mental, mob.negative, mob.poison, mob.shadow, mob.sonic, mob.water))
  
  -- convert the table to a SQL entry and insert
  if DatabaseError(db) == "not an error" then
      Note("Mob info successfully captured to database.")
  else
      Note("Database error: " .. DatabaseError(db))
  end
  EnableTriggerGroup("capture_entry", false)
end

function CheckIfCatalogued(name)
  --check if name + room + zone exists
  catalogued = "false" -- make this the lookup instead
  if catalogued == false then
    iq = 0 --enable alias to interrogate
  end
end

function HeaderDisable()
  EnableTrigger("header", false)
end

function dump(o)
   if type(o) == 'table' then
      local s = '{ '
      for k,v in pairs(o) do
         if type(k) ~= 'number' then k = '"'..k..'"' end
         s = s .. '['..k..'] = ' .. dump(v) .. ','
      end
      return s .. '} '
   else
      return tostring(o)
   end
end

]]>
</script>



<aliases> -- interrrogate interrupt alias
  <alias
   match="k *"
   enabled="y"
   sequence="100"
  >
    <send>spellup silent
    interrogate %1
    kill %1</send>
  </alias>
  <alias
   match="inq-wipedb"
   enabled="y"
   send_to="12"
   sequence="100"
  >
    <send>WipeDB()</send>
  </alias>
    <alias
   match="inq-closedb"
   enabled="y"
   send_to="12"
   sequence="100"
  >
    <send>CloseDB()</send>
  </alias>
    <alias
   match="inq-testinsert"
   enabled="y"
   send_to="12"
   sequence="100"
  >
    <send>TestInsert()</send>
  </alias>
</aliases>

<!--  Triggers  -->

<triggers>
  <trigger
   enabled="y"
   group="start_inquisitor"
   match="^As you mercilessly interrogate"
   regexp="y"
   omit_from_output="y"
   send_to="12"
   sequence="99"
  >
  <send>InterrogationSuccessful()</send>
  </trigger>
  <trigger
   enabled="n"
   group="capture_entry"
   name="header"
   match="----------------------------------------------------------------"
   omit_from_output="y"
   send_to="12"
   sequence="100"
  >
  <send>HeaderDisable()</send>
  </trigger>
  <trigger
   enabled="n"
   group="capture_entry"
   match="Mob Short Name   : (([,'\-\w]\s?)+)$"
   omit_from_output="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>Capture("Name", "%1")</send>
  </trigger>
  <trigger
   enabled="n"
   group="capture_entry"
   match="Mob Base Level   : ([\d]+)$"
   regexp="y"
   omit_from_output="y"
   send_to="12"
   sequence="100"
  >
  <send>Capture("Level", "%1")</send>
  </trigger>
  <trigger
   enabled="n"
   group="capture_entry"
   match="Guild            : (([,'\-\w]\s?)+)$"
   omit_from_output="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>Capture("Guild", "%1")</send>
  </trigger>
  <trigger
   enabled="n"
   group="capture_entry"
   match="Subclass         : (([,'\-\w]\s?)+)$"
   omit_from_output="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>Capture("Subclass", "%1")</send>
  </trigger>
    <trigger
   enabled="n"
   group="capture_entry"
   match="Identical Mobs   : ([\d]+)$"
   omit_from_output="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>Capture("Identical", "%1")</send>
  </trigger>
    <trigger
   enabled="n"
   group="capture_entry"
   match="Times Killed     : ([\d]+)$"
   omit_from_output="y"
   regexp="y"
   sequence="100"
  >
  </trigger>
    <trigger
   enabled="n"
   group="capture_entry"
   match="Mob Hp           : *([\d]+)\/([\d]+)"
   omit_from_output="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>Capture("Hp", "%2")</send>
  </trigger>
    <trigger
   enabled="n"
   group="capture_entry"
   match="Alignment        : (([,'\-\.\w]\s?)+)$"
   regexp="y"
   omit_from_output="y"
   send_to="12"
   sequence="100"
  >
  <send>ParseAlignment("%1")</send>
  </trigger>
  <trigger
   enabled="n"
   group="capture_entry"
   match="Note             : (([,'\-\.\w]\s?)+)$"
   regexp="y"
   omit_from_output="y"
   sequence="100"
  >
  </trigger> -- we're just throwing away the notes, they're too general to be useful
  <trigger
   enabled="n"
   group="capture_entry"
   match="------------------------- [ Resistances ] ----------------------"
   omit_from_output="y"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="n"
   group="capture_entry"
   match="([^\s]+)[\s:]+([0-9\-\.]+)%"
   regexp="y"
   omit_from_output="y"
   keep_evaluating="y"
   send_to="12"
   sequence="100"
  >
  <send>CaptureResist("%1", "%2")</send>
  </trigger> -- may need to check syntax on keep evaluating or if it's appropriate
  <trigger
   enabled="n"
   group="capture_entry"
   name="footer"
   match="----------------------------------------------------------------"
   omit_from_output="y"
   send_to="12"
   sequence="101"
  >
  <send>PostEntry()</send>
  </trigger>
  <trigger match="^\{rname\}(?P<room>.*)"
    name="inquisitor_room" script="CaptureRoom" enabled="y"  keep_evaluating="y"  regexp="y"  omit_from_output="y"  send_to="12"  sequence="50"  >
</trigger>
</triggers>

</muclient>

