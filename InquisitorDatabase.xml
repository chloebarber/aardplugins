<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Tuesday, March 25, 2025, 7:36 PM -->
<!-- MuClient version 5.07-pre -->

<!-- Plugin "Inquisitor" generated by Plugin Wizard -->

<muclient>
<plugin
   name="InquisitorDatabase"
   author="Bartoc"
   id="a0df32eada26b5a8bdec0c87"
   language="Lua"
   purpose="Builds a mob database using Interrogate"
   save_state="y"
   date_written="2025-03-25 19:35:24"
   requires="5.07"
   version="1.0"
   >

</plugin>


<!--  Variables  -->

<variables>
</variables>

<!--  Script  -->


<script>
<![CDATA[

require 'gmcphelper'

db = "InquisitorDB"
mob = {}
interrogate_ready = true
debug = false

function ToggleDebug()
  if debug then
    Note("Debug mode disabled")
  else
    Note("Debug mode enabled")
  end
  debug = not debug
end

function ResetMob()
    mob = {
      uniqid = "defaultID", 
      partial = "false",
      name = "poop", 
      room = "poop", 
      zone = "poop", 
      level = 0, 
      guild = "poop", 
      subclass = "poop",
      identical = 0, 
      hp = 0, 
      alignment = "poop", 
      bash = 0.0, 
      pierce = 0.0, 
      slash = 0.0, 
      acid = 0.0, 
      air = 0.0, 
      cold = 0.0, 
      disease = 0.0, 
      earth = 0.0, 
      energy = 0.0, 
      fire = 0.0, 
      holy = 0.0, 
      light = 0.0, 
      electric = 0.0, 
      magic = 0.0, 
      mental = 0.0, 
      negative = 0.0, 
      poison = 0.0, 
      shadow = 0.0, 
      sonic = 0.0, 
      water = 0.0,
    }
end

function OnPluginInstall()
  GenTable()
end

function WipeDB()
  DatabaseExec (db, [[
    DROP TABLE IF EXISTS mobs;
      ]])
  Note("Wiped Inquisitor DB")
end

function CloseDB()
  DatabaseClose(db)
  Note("Closed DB")
end

function TestInsert()
  ResetMob()
  --Note(dump(mob))

  keys = {}
  values = {}
  for key, value in pairs(mob) do
      table.insert(keys, key)
      table.insert(values, value)
  end

  mob.zone = gmcp("room.info.zone")
  mob.uniqid = mob.zone .. "+" .. mob.room .. "+" .. mob.name
  
  Note(string.format([[
  INSERT INTO mobs (
  uniqid, name, room, zone, level, guild, subclass, identical, hp, alignment, bash, pierce, slash, acid, air, cold, disease, earth, energy, fire, holy, light, electric, magic, mental, negative, poison, shadow, sonic, water)
  VALUES 
  (%s, %s, %s, %s, %d, %s, %s, %d, %d, %s, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d)
  ]], 
  mob.uniqid, mob.name, mob.room, mob.zone, mob.level, mob.guild, mob.subclass, mob.identical, mob.hp, mob.alignment, mob.bash, mob.pierce, mob.slash, mob.acid, mob.air, mob.cold, mob.disease, mob.earth, mob.energy, mob.fire, mob.holy, mob.light, mob.electric, mob.magic, mob.mental, mob.negative, mob.poison, mob.shadow, mob.sonic, mob.water))
end

function GenTable()
  DatabaseOpen(db, GetInfo(66) .. "inquisitor.sqlite", 6)
  Note("Opened DB")
  DatabaseExec (db, [[
    CREATE TABLE IF NOT EXISTS mobs (
        uniqid TEXT NOT NULL PRIMARY KEY,
        partial TEXT NOT NULL,
        name      TEXT NOT NULL,
        room      TEXT NOT NULL,
        zone      TEXT NOT NULL,
        level     INT NOT NULL,
        guild      TEXT NOT NULL,
        subclass      TEXT NOT NULL,
        identical   INT,
        hp    INT,
        alignment   TEXT NOT NULL,
        bash    REAL,
        pierce    REAL,
        slash    REAL,
        acid    REAL,
        air    REAL,
        cold    REAL,
        disease    REAL,
        earth    REAL,
        energy    REAL,
        fire    REAL,
        holy    REAL,
        light    REAL,
        electric     REAL,
        magic    REAL,
        mental    REAL,
        negative    REAL,
        poison    REAL,
        shadow    REAL,
        sonic    REAL,
        water    REAL
      );
      ]])
  -- DatabaseClose(db)
  -- Note("Closed DB")
end

function ResetInterrogate()
  interrogate_ready = true
  Note("Interrogate ready")
end

function InterrogateInjection(target)
  --DatabasePrepare(db, "SELECT * FROM mobs WHERE") -- check for key
  --DatabaseStep (db)
  --DatabaseFinalize (db)

  if interrogate_ready then
    Send("spellup silent")
    Send("interrogate " .. target)
    Send("kill " .. target)
  else
    Send("spellup silent")
    Send("kill " .. target)
  end
end

function InterrogationSuccessful()
  Note("Interrogation successful.")
  interrogate_ready = false
  mob.zone = "currentzone"
  EnableTriggerGroup("capture_entry", true)
  if debug then Note("Trigger group activated") end
end

function Capture(flag, data)
  if debug then Note("Data captured - " .. flag .. ": " .. data) end
  if type(data) == "string" then data = data:gsub("'", "''") end -- single quotes break sqlite
  mob[flag] = data
end

function CaptureRoom(name, line, wildcards, styles)
  styles[2].text = styles[2].text:gsub("'", "''") -- single quotes break sqlite
  --Note("Room captured: " .. styles[2].text)
  mob["room"] = styles[2].text
end

function CaptureResist(name, data)
  sorted = {}
  --we're just capturing these separately to build an easily sorted list
  --ordering resists on capture reduces complexity of weakpoint analysis on run I think
  Capture(string.lower(name), data)
  -- Capture("ResistanceList", sorted)
end

function ParseAlignment(flavortext)
  alignvalue = ""
  flavortext_short = string.sub(flavortext, string.len(mob.name)+4, string.len(flavortext)-1) -- removes mob name + "is" + ending period
  -- map flavor text to alignment range
  Capture("alignment", flavortext_short)
end


immunities = {}
function ProcessImmunities(raw)
  for immunity in raw:gmatch("%w+") do 
    table.insert(immunities, immunity) 
  end
end

function PostEntry()

  mob.zone = gmcp("room.info.zone")
  mob.uniqid = mob.zone .. "+" .. mob.room .. "+" .. mob.name

  for key, value in pairs(immunities) do -- JUST in case the mob somehow had a resistance AND an immunity to the same type, we overwrite with the immunity's 100%
    if debug then Note("Immunity: " .. value) end
    mob[value] = 100.0
  end
  immunities = {}

  
  -- convert the table to a SQL entry and insert
  DatabaseExec (db, string.format([[
    INSERT INTO mobs (
    uniqid, partial, name, room, zone, level, guild, subclass, identical, hp, alignment, bash, pierce, slash, acid, air, cold, disease, earth, energy, fire, holy, light, electric, magic, mental, negative, poison, shadow, sonic, water)
    VALUES 
    ('%s', '%s', '%s', '%s', '%s', %d, '%s', '%s', %d, %d, '%s', %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d)
    ]], 
    mob.uniqid, mob.partial, mob.name, mob.room, mob.zone, mob.level, mob.guild, mob.subclass, mob.identical, mob.hp, mob.alignment, mob.bash, mob.pierce, mob.slash, mob.acid, mob.air, mob.cold, mob.disease, mob.earth, mob.energy, mob.fire, mob.holy, mob.light, mob.electric, mob.magic, mob.mental, mob.negative, mob.poison, mob.shadow, mob.sonic, mob.water))
  
  
  if DatabaseError(db) == "not an error" then
      Note("Mob info successfully captured to database.")
  else
      Note("@RDatabase error: " .. DatabaseError(db))
      Note("Mob data dump: " .. dump(mob))
      Note("@GThis shouldn't happen: please contact Bartoc in-game on on the Aardwolf Discord server and send the above error message and data dump.)
  end
  EnableTriggerGroup("capture_entry", false)
  ResetMob()

end

function CheckIfCatalogued(name)
  --check if name + room + zone exists
  catalogued = "false" -- make this the lookup instead
  if catalogued == false then
    iq = 0 --enable alias to interrogate
  end
end

function HeaderDisable()
  EnableTrigger("header", false)
end

function dump(o)
   if type(o) == 'table' then
      local s = '{ '
      for k,v in pairs(o) do
         if type(k) ~= 'number' then k = '"'..k..'"' end
         s = s .. '['..k..'] = ' .. dump(v) .. ','
      end
      return s .. '} '
   else
      return tostring(o)
   end
end

]]>
</script>



<aliases> -- interrrogate interrupt alias
  <alias
   match="k *"
   enabled="y"
   send_to="12"
   sequence="100"
  >
    <send>InterrogateInjection("%1")</send>
  </alias>
  <alias
   match="inq-debug"
   enabled="y"
   send_to="12"
   sequence="100"
  >
    <send>ToggleDebug()</send>
  </alias>
  <alias
   match="inq-wipedb"
   enabled="y"
   send_to="12"
   sequence="100"
  >
    <send>WipeDB()</send>
  </alias>
    <alias
   match="inq-closedb"
   enabled="y"
   send_to="12"
   sequence="100"
  >
    <send>CloseDB()</send>
  </alias>
    <alias
   match="inq-testinsert"
   enabled="y"
   send_to="12"
   sequence="100"
  >
    <send>TestInsert()</send>
  </alias>
</aliases>

<!--  Triggers  -->

<triggers>
  <trigger
   enabled="y"
   name="interrogatecooldown"
   match="## You may now use Interrogation abilities."
   regexp="y"
   omit_from_output="y"
   send_to="12"
   sequence="101"
  >
  <send>ResetInterrogate()</send>
  </trigger>
  <trigger
   enabled="y"
   group="start_inquisitor"
   match="^As you mercilessly interrogate"
   regexp="y"
   omit_from_output="y"
   send_to="12"
   sequence="99"
  >
  <send>InterrogationSuccessful()</send>
  </trigger>
  <trigger
   enabled="n"
   group="capture_entry"
   name="header"
   match="----------------------------------------------------------------"
   omit_from_output="y"
   send_to="12"
   sequence="100"
  >
  <send>HeaderDisable()</send>
  </trigger>
  <trigger
   enabled="n"
   group="capture_entry"
   match="Mob Short Name   : (([,'\-\w]\s?)+)$"
   omit_from_output="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>Capture("name", "%1")</send>
  </trigger>
  <trigger
   enabled="n"
   group="capture_entry"
   match="Mob Base Level   : ([\d]+)$"
   regexp="y"
   omit_from_output="y"
   send_to="12"
   sequence="100"
  >
  <send>Capture("level", "%1")</send>
  </trigger>
  <trigger
   enabled="n"
   group="capture_entry"
   match="Guild            : (([,'\-\w]\s?)+)$"
   omit_from_output="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>Capture("guild", "%1")</send>
  </trigger>
  <trigger
   enabled="n"
   group="capture_entry"
   match="Subclass         : (([,'\-\w]\s?)+)$"
   omit_from_output="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>Capture("subclass", "%1")</send>
  </trigger>
    <trigger
   enabled="n"
   group="capture_entry"
   match="Identical Mobs   : ([\d]+)$"
   omit_from_output="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>Capture("identical", "%1")</send>
  </trigger>
    <trigger
   enabled="n"
   group="capture_entry"
   match="Times Killed     : ([\d]+)$"
   omit_from_output="y"
   regexp="y"
   sequence="100"
  >
  </trigger>
    <trigger
   enabled="n"
   group="capture_entry"
   match="Mob Hp           : *([\d]+)\/([\d]+)"
   omit_from_output="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>Capture("hp", "%2")</send>
  </trigger>
    <trigger
   enabled="n"
   group="capture_entry"
   match="Alignment        : (([,'\-\.\w]\s?)+)$"
   regexp="y"
   omit_from_output="y"
   send_to="12"
   sequence="100"
  >
  <send>ParseAlignment("%1")</send>
  </trigger>
  <trigger
   enabled="n"
   group="capture_entry"
   name="immunities"
   match="^Immunities       : (.*)$"
   regexp="y"
   omit_from_output="y"
   send_to="12"
   sequence="100"
  >
  <send>ProcessImmunities("%1")</send>
  </trigger>
  <trigger
   enabled="n"
   group="capture_entry"
   match="Note             : (([,'\-\.\w]\s?)+)$"
   regexp="y"
   omit_from_output="y"
   sequence="100"
  >
  </trigger> -- we're just throwing away the notes, they're too general to be useful
  <trigger
   enabled="n"
   group="capture_entry"
   match="------------------------- [ Resistances ] ----------------------"
   omit_from_output="y"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="n"
   group="capture_entry"
   match="([^\s]+)[\s:]+([0-9\-\.]+)%      ([^\s]+)[\s:]+([0-9\-\.]+)%"
   regexp="y"
   omit_from_output="y"
   send_to="12"
   sequence="99"
  >
  <send>CaptureResist("%1", "%2")
  CaptureResist("%3", "%4")</send> -- fucking disgusting but it's the easy way to capture 2 resists a line
  </trigger>
  <trigger
   enabled="n"
   group="capture_entry"
   match="([^\s]+)[\s:]+([0-9\-\.]+)%"
   regexp="y"
   omit_from_output="y"
   send_to="12"
   sequence="101"
  >
  <send>CaptureResist("%1", "%2")</send> -- if this runs alone it short circuits multiple resists on the same line due to omit output
  </trigger> 
  <trigger
   enabled="n"
   group="capture_entry"
   name="footer"
   match="----------------------------------------------------------------"
   omit_from_output="y"
   send_to="12"
   sequence="101"
  >
  <send>PostEntry()</send>
  </trigger>
  <trigger match="^\{rname\}(?P<room>.*)"
    name="inquisitor_room" script="CaptureRoom" enabled="y"  keep_evaluating="y"  regexp="y"  omit_from_output="y"  send_to="12"  sequence="50"  >
</trigger>
</triggers>

</muclient>

