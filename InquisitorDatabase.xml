<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Tuesday, March 25, 2025, 7:36 PM -->
<!-- MuClient version 5.07-pre -->

<!-- Plugin "Inquisitor" generated by Plugin Wizard -->

<muclient>
<plugin
   name="InquisitorDatabase"
   author="Bartoc"
   id="a0df32eada26b5a8bdec0c87"
   language="Lua"
   purpose="Builds a mob database using Interrogate"
   save_state="y"
   date_written="2025-03-25 19:35:24"
   requires="5.07"
   version="1.0"
   >

</plugin>


<!--  Variables  -->

<variables>
</variables>

<!--  Script  -->


<script>
<![CDATA[

mob = {} -- 

<!-- 
Name
Room
Zone
Level
Guild
Subclass
Alignment
ResistanceList
Bash
Pierce
Slash
Acid
Air
Cold
Disease
Earth
Energy
Fire
Holy
Light
Electric ("Lighting"?)
Magic
Mental
Negative
Poison
Shadow
Sonic
Water
 -->

function InterrogationSuccessful()
  mob = {}
  EnableTriggerGroup("capture_entry", true)
  mob.Zone = "currentzone"
  mob.Room = "currentroom"
  Note("Interrogation successful.")
end

function Capture(flag, data)
  mob[flag] = data
end

CaptureResist("name", data)
  sorted = {}
  --we're just capturing these separately to build an easily sorted list
  --ordering resists on capture reduces complexity of weakpoint analysis on run I think
  Capture(flag, data)
  Capture("ResistanceList", sorted)
end

function ParseAlignment(flavortext)
  alignvalue = ""
  -- map flavor text to alignment range
  Capture("Alignment", alignvalue)
end

function PostEntry()
  -- convert the table to a SQL entry and insert
  EnableTriggerGroup("capture_entry", false)
  Note("Mob info captured.")
end

function CheckIfCatalogued(name)
  --check if name + room + zone exists
  catalogued = "false" -- make this the lookup instead
  if catalogued == false then
    --enable alias to interrogate
  end
end

function HeaderDisable()
  EnableTrigger("header", false)
end

]]>
</script>


</muclient>

<!--  Triggers  -->

<triggers>
  <trigger
   enabled="y"
   group="start_inquisitor"
   match="As you mercilessly interrogate *, you learn ..."
   omit_from_output="y"
   sequence="100"
  >
  <send>InterrogateSuccessful()</send>
  </trigger>
  <trigger
   enabled="n"
   group="capture_entry"
   name="header"
   match="----------------------------------------------------------------"
   omit_from_output="y"
   sequence="100"
  >
  <send>HeaderDisable()</send>
  </trigger>
  <trigger
   enabled="n"
   group="capture_entry"
   match="Mob Short Name   : (*)"
   omit_from_output="y"
   sequence="100"
  >
  <send>Capture("Name", "%1")</send>
  </trigger>
  <trigger
   enabled="n"
   group="capture_entry"
   match="Mob Base Level   : (*)"
   omit_from_output="y"
   sequence="100"
  >
  <send>Capture("Level", "%1")</send>
  </trigger>
  <trigger
   enabled="n"
   group="capture_entry"
   match="Guild            : (*)"
   omit_from_output="y"
   sequence="100"
  >
  <send>Capture("Guild", "%1")</send>
  </trigger>
  <trigger
   enabled="n"
   group="capture_entry"
   match="Subclass         : (*)"
   omit_from_output="y"
   sequence="100"
  >
  <send>Capture("Subclass", "%1")</send>
  </trigger>
    <trigger
   enabled="n"
   group="capture_entry"
   match="Alignment        : (*)"
   omit_from_output="y"
   sequence="100"
  >
  <send>ParseAlignment("1%")</send>
  </trigger>
  <trigger
   enabled="n"
   group="capture_entry"
   match="Note             : (*)"
   omit_from_output="y"
   sequence="100"
  >
  </trigger> -- we're just throwing away the notes
  <trigger
   enabled="n"
   group="capture_entry"
   match="------------------------- [ Resistances ] ----------------------"
   omit_from_output="y"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="n"
   group="capture_entry"
   match="([^\s]+)[\s:]+([0-9\.]+)%"
   omit_from_output="y"
   keep_evaluating="y"
   sequence="100"
  > -- may need to check syntax on keep evaluating or if it's appropriate
  <send>CaptureResist("%1", "%2")</send>
  </trigger>
  <trigger
   enabled="n"
   group="capture_entry"
   name="footer"
   match="----------------------------------------------------------------"
   omit_from_output="y"
   sequence="101"
  >
  <send>PostEntry()</send>
  </trigger>
</triggers>


<!-- 
Example of creating a database


db = "mainDatabase"  -- internal identifier

DatabaseOpen (db, GetInfo (66) .. "mytestdb.sqlite", 6)

DatabaseExec (db, [[
DROP TABLE IF EXISTS weapons;
CREATE TABLE weapons(
        weapon_id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
        name      TEXT NOT NULL,
        damage    INT DEFAULT 10,
        weight    REAL
      );
      ]])
      
DatabaseClose (db)  -- close it



It is better to check the result from calling functions like DatabaseExec, otherwise they may silently fail (eg, with an SQL syntax error) like this:


status = DatabaseExec (db, [[
DROP TABLE IF EXISTS weapons;
CREATE TABLE weapons(
        weapon_id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
        name      TEXT NOT NULL,
        damage    INT DEFAULT 10,
        weight    REAL
      );
      ]])
      
if status ~= sqlite3.OK then
  print ("Error creating weapons table: ", DatabaseError(db))
end -- if not OK



The documentation for DatabaseExec suggests a function (dbcheck) which can be used as a generic return-code checker. 



-------------Example of adding a row of data


DatabaseExec (db, "INSERT INTO weapons (name, damage) VALUES ('Nick''s sword', 42)")



Note that if you need to use quotes inside a string, the quotes must be doubled, as shown above.



----------Example of selecting some rows and displaying them

As described above, you need to "prepare" the SQL statement first. Once prepared you can find how many columns are in it, and the column names.

Then you "step" through the rows, one by one, getting the column values. These can then be printed, saved, or acted up.

Finally you "finalize" the SQL statement, releasing it so you can do another operation.


-- prepare a query
DatabasePrepare (db, "SELECT * FROM weapons ORDER BY name")

-- find the column names
names = DatabaseColumnNames (db)

-- find how many columns there are
cols = DatabaseColumns (db)

-- step to get the first row
rc = DatabaseStep (db)  -- read first row

-- now loop, displaying each row, and getting the next one
while rc == sqlite3.ROW do
  
  print ("")
  values = DatabaseColumnValues (db)

  for i = 1, cols do
    print (names [i], "=", values [i])
  end -- for each column

  rc = DatabaseStep (db)  -- read next row

end -- while loop

-- finished with the statement
DatabaseFinalize (db)



You should really check the return code from DatabasePrepare in case you have an error in the SQL statement, as shown above for DatabaseExec.

-----------full Example using the Lua interface


require "tprint"

-- make in-memory database
db = sqlite3.open_memory()

-- make a table for testing
db:exec  [[
          CREATE TABLE mobs (name, class, hp);
          INSERT INTO mobs VALUES("Naga", "mage", 666);
          INSERT INTO mobs VALUES("Wolf", "beast", 42);
          INSERT INTO mobs VALUES("Guard", "warrior", 100);
       ]]

-- prepare a SELECT statement
local stmt = db:prepare ("SELECT * FROM mobs")

-- loop until we get everything
while true do

  local result = stmt:step ()

  -- exit loop if done
  if result == sqlite3.DONE then
    break
  end -- if done

  -- should have ROW result
  assert (result == sqlite3.ROW, "Row not found")

  -- get all values into a table
  local row = stmt:get_named_values()

  -- display them
  print (string.rep ("-", 20))
  tprint (row)
  
end -- while

-- done with this statement
stmt:finalize ()

-- finished with database
db:close ()

-->